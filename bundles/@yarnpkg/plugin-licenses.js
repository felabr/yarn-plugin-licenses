/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-licenses",
factory: function (require) {
var plugin;plugin=(()=>{"use strict";var __webpack_modules__={195:(e,t,r)=>{r.r(t),r.d(t,{default:()=>O});var n={};r.r(n),r.d(n,{fs:()=>d,getPackagePath:()=>l});const i=require("@yarnpkg/cli");var a=r(966);const s=require("clipanion");var o=r(688),_=r(300);const c=require("@yarnpkg/parsers"),l=async(e,t)=>{await u(e);const r=a.structUtils.convertPackageToLocator(t),n=p[a.structUtils.stringifyLocator(r)];if(!n)return null;const i=n.locations[0];return i?o.ppath.join(e.cwd,i):e.cwd};let p;const u=async e=>{if(!p){const t=o.ppath.join(e.configuration.projectCwd,o.Filename.nodeModules,".yarn-state.yml");p=(0,c.parseSyml)(await o.xfs.readFilePromise(t,"utf8"))}},d=o.xfs,f=e=>{switch(e){case"pnp":return _;case"node-modules":return n;default:throw new Error("Unsupported linker")}},g=("@yarnpkg"===o.npath.basename(__dirname)?o.ppath.join(o.npath.toPortablePath(__dirname),"../.."):o.ppath.join(o.npath.toPortablePath(__dirname),".."),(e,t)=>{const r=new Map;let n;n=t?e.storedDescriptors.values():e.workspaces.flatMap(e=>{const t=[e.anchoredDescriptor];return t.push(...e.dependencies.values()),t});const i=a.miscUtils.sortMap(n,[e=>a.structUtils.stringifyIdent(e),e=>a.structUtils.isVirtualDescriptor(e)?"0":"1",e=>e.range]),s=new Set;for(const t of i.values()){const n=e.storedResolutions.get(t.descriptorHash);if(!n)continue;const i=e.storedPackages.get(n);if(!i)continue;const{descriptorHash:o}=a.structUtils.isVirtualDescriptor(t)?a.structUtils.devirtualizeDescriptor(t):t;s.has(o)||(s.add(o),r.set(t,i))}return r}),m=e=>{const{license:t,repository:r,homepage:n,author:i}=e;return{license:("string"!=typeof t?null==t?void 0:t.type:t)||"UNKNOWN",url:(null==r?void 0:r.url)||n,vendorName:null==i?void 0:i.name,vendorUrl:n||(null==i?void 0:i.url)}},h=(e,t,r)=>r?t:`${e}: ${t}`;var w=function(e,t,r,n){var i,a=arguments.length,s=a<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,n);else for(var o=e.length-1;o>=0;o--)(i=e[o])&&(s=(a<3?i(s):a>3?i(t,r,s):i(t,r))||s);return a>3&&s&&Object.defineProperty(t,r,s),s};class P extends s.Command{constructor(){super(...arguments),this.recursive=!1,this.json=!1}async execute(){const e=await a.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:r}=await a.Project.find(e,this.context.cwd);if(!r)throw new i.WorkspaceRequiredError(t.cwd,this.context.cwd);await t.restoreInstallState();const n=await(async(e,t,r)=>{const n={},i={children:n},s=g(e,r),_=f(e.configuration.get("nodeLinker"));for(const[r,i]of s.entries()){const s=await _.getPackagePath(e,i);if(null===s)continue;const c=JSON.parse(await _.fs.readFilePromise(o.ppath.join(s,o.Filename.manifest),"utf8")),{license:l,url:p,vendorName:u,vendorUrl:d}=m(c);n[l]||(n[l]={value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,l),children:{}});const f=a.structUtils.convertPackageToLocator(i),g={value:a.formatUtils.tuple(a.formatUtils.Type.DEPENDENT,{locator:f,descriptor:r}),children:{...p?{url:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,h("URL",p,t))}}:{},...u?{vendorName:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,h("VendorName",u,t))}}:{},...d?{vendorUrl:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,h("VendorUrl",d,t))}}:{}}},w=a.structUtils.stringifyLocator(f);n[l].children[w]=g}return i})(t,this.json,this.recursive);a.treeUtils.emitTree(n,{configuration:e,stdout:this.context.stdout,json:this.json,separators:1})}}P.usage=s.Command.Usage({description:"display the licenses for all packages in the project",details:"\n      This command prints the license information for packages in the project. By default, only direct dependencies are listed.\n\n      If `-R,--recursive` is set, the listing will include transitive dependencies (dependencies of direct dependencies).\n    ",examples:[["List all licenses of direct dependencies","$0 licenses list"],["List all licenses of direct and transitive dependencies","$0 licenses list --recursive"]]}),w([s.Command.Boolean("-R,--recursive")],P.prototype,"recursive",void 0),w([s.Command.Boolean("--json")],P.prototype,"json",void 0),w([s.Command.Path("licenses","list")],P.prototype,"execute",null);var k=function(e,t,r,n){var i,a=arguments.length,s=a<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,n);else for(var o=e.length-1;o>=0;o--)(i=e[o])&&(s=(a<3?i(s):a>3?i(t,r,s):i(t,r))||s);return a>3&&s&&Object.defineProperty(t,r,s),s};class y extends s.Command{constructor(){super(...arguments),this.recursive=!1}async execute(){const e=await a.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:r}=await a.Project.find(e,this.context.cwd);if(!r)throw new i.WorkspaceRequiredError(t.cwd,this.context.cwd);await t.restoreInstallState();const n=await(async(e,t)=>{const r=g(e,t),n=f(e.configuration.get("nodeLinker")),i=new Map;for(const t of r.values()){const r=await n.getPackagePath(e,t);if(null===r)continue;const a=JSON.parse(await n.fs.readFilePromise(o.ppath.join(r,o.Filename.manifest),"utf8")),s=(await n.fs.readdirPromise(r,{withFileTypes:!0})).filter(e=>e.isFile()).map(({name:e})=>e),_=s.find(e=>{const t=e.toLowerCase();return"license"===t||t.startsWith("license.")||"unlicense"===t||t.startsWith("unlicense.")});if(!_)continue;const c=await n.fs.readFilePromise(o.ppath.join(r,_),"utf8"),l=s.find(e=>{const t=e.toLowerCase();return"notice"===t||t.startsWith("notice.")});let p;l&&(p=await n.fs.readFilePromise(o.ppath.join(r,l),"utf8"));const u=p?`${c}\n\nNOTICE\n\n${p}`:c,d=i.get(u);d?d.set(a.name,a):i.set(u,new Map([[a.name,a]]))}let a=`THE FOLLOWING SETS FORTH ATTRIBUTION NOTICES FOR THIRD PARTY SOFTWARE THAT MAY BE CONTAINED IN PORTIONS OF THE ${String(e.topLevelWorkspace.manifest.raw.name).toUpperCase().replace(/-/g," ")} PRODUCT.\n\n`;for(const[e,t]of i.entries()){a+="-----\n\n";const r=[],n=[];for(const{name:e,repository:i}of t.values())r.push(e),(null==i?void 0:i.url)&&n.push(1===t.size?i.url:`${i.url} (${e})`);const i=[];i.push(`The following software may be included in this product: ${r.join(", ")}.`),n.length>0&&i.push(`A copy of the source code may be downloaded from ${n.join(", ")}.`),i.push("This software contains the following license and notice below:"),a+=i.join(" ")+"\n\n",a+=e.trim()+"\n\n"}return a})(t,this.recursive);this.context.stdout.write(n)}}y.usage=s.Command.Usage({description:"display the license disclaimer including all packages in the project",details:"\n      This command prints the license disclaimer for packages in the project. By default, only direct dependencies are listed.\n\n      If `-R,--recursive` is set, the disclaimer will include transitive dependencies (dependencies of direct dependencies).\n    ",examples:[["Include licenses of direct dependencies","$0 licenses generate-disclaimer"],["Include licenses of direct and transitive dependencies","$0 licenses generate-disclaimer --recursive"]]}),k([s.Command.Boolean("-R,--recursive")],y.prototype,"recursive",void 0),k([s.Command.Path("licenses","generate-disclaimer")],y.prototype,"execute",null);const O={commands:[P,y]}},300:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{getPackagePath:()=>getPackagePath,fs:()=>fs});var _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(798),_yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_0__),_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(966),_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1___default=__webpack_require__.n(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__),_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(688),_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2___default=__webpack_require__.n(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__),_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(76),_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_3___default=__webpack_require__.n(_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_3__);const getPackagePath=async(e,t)=>{makePnPApi(e);const r=_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.convertPackageToLocator(t),n={name:_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.stringifyIdent(r),reference:r.reference},i=pnpApi.getPackageInformation(n);if(!i)return null;const{packageLocation:a}=i;return a};let pnpApi;const makePnPApi=project=>{pnpApi||(pnpApi=eval("module.require")((0,_yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_0__.getPnpPath)(project).main))},fs=new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.VirtualFS({baseFs:new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ZipOpenFS({libzip:(0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_3__.getLibzipSync)(),readOnlyArchives:!0})})},966:e=>{e.exports=require("@yarnpkg/core")},688:e=>{e.exports=require("@yarnpkg/fslib")},76:e=>{e.exports=require("@yarnpkg/libzip")},798:e=>{e.exports=require("@yarnpkg/plugin-pnp")}},__webpack_module_cache__={};function __webpack_require__(e){if(__webpack_module_cache__[e])return __webpack_module_cache__[e].exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}return __webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(e,t)=>{for(var r in t)__webpack_require__.o(t,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__(195)})();
return plugin;
}
};