/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-licenses",
factory: function (require) {
var plugin=(()=>{var se=Object.create,U=Object.defineProperty;var re=Object.getOwnPropertyDescriptor;var ae=Object.getOwnPropertyNames,_=Object.getOwnPropertySymbols,ce=Object.getPrototypeOf,z=Object.prototype.hasOwnProperty,le=Object.prototype.propertyIsEnumerable;var K=(e,n,t)=>n in e?U(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,F=(e,n)=>{for(var t in n||(n={}))z.call(n,t)&&K(e,t,n[t]);if(_)for(var t of _(n))le.call(n,t)&&K(e,t,n[t]);return e};var de=e=>U(e,"__esModule",{value:!0});var f=e=>{if(typeof require!="undefined")return require(e);throw new Error('Dynamic require of "'+e+'" is not supported')};var H=(e,n)=>{for(var t in n)U(e,t,{get:n[t],enumerable:!0})},pe=(e,n,t)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of ae(n))!z.call(e,i)&&i!=="default"&&U(e,i,{get:()=>n[i],enumerable:!(t=re(n,i))||t.enumerable});return e},u=e=>pe(de(U(e!=null?se(ce(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var ve={};H(ve,{default:()=>be});var ee=u(f("@yarnpkg/cli")),x=u(f("@yarnpkg/core")),w=u(f("clipanion"));var a=u(f("@yarnpkg/core")),g=u(f("@yarnpkg/fslib"));var R={};H(R,{fs:()=>ge,getPackagePath:()=>fe});var q=u(f("@yarnpkg/plugin-pnp")),W=u(f("@yarnpkg/core")),S=u(f("@yarnpkg/fslib")),J=u(f("@yarnpkg/libzip")),fe=async(e,n)=>{ue(e);let t=W.structUtils.convertPackageToLocator(n),i={name:W.structUtils.stringifyIdent(t),reference:t.reference},s=$.getPackageInformation(i);if(!s)return null;let{packageLocation:l}=s;return l},$,ue=e=>{$||($=module.require((0,q.getPnpPath)(e).cjs))},ge=new S.VirtualFS({baseFs:new S.ZipOpenFS({libzip:(0,J.getLibzipSync)(),readOnlyArchives:!0})});var A={};H(A,{fs:()=>Pe,getPackagePath:()=>me});var D=u(f("@yarnpkg/core")),Y=u(f("@yarnpkg/parsers")),k=u(f("@yarnpkg/fslib")),me=async(e,n)=>{await he(e);let t=D.structUtils.convertPackageToLocator(n),i=T[D.structUtils.stringifyLocator(t)];if(!i){console.log("getPackagePath entry lookup failed..."),console.log("looking for:",D.structUtils.stringifyLocator(t));let l=t.scope?`@${t.scope}/${t.name}`:t.name,d=t.reference.slice(t.reference.lastIndexOf(":")),o=Object.keys(T).filter(r=>r.startsWith(l)&&r.endsWith(d));console.log("found these in the yarnState:",o);let c=Object.keys(T).find(r=>r.startsWith(l)&&r.endsWith(d));if(console.log("using this one instead:",c),!c)return console.log("nothing found"),null;i=T[c]}let s=i.locations[0];return s?k.ppath.join(e.cwd,s):e.cwd},T,he=async e=>{if(!T){let n=k.ppath.join(e.configuration.projectCwd,k.Filename.nodeModules,".yarn-state.yml");T=(0,Y.parseSyml)(await k.xfs.readFilePromise(n,"utf8"))}},Pe=k.xfs;var B=e=>{switch(e){case"pnp":return R;case"node-modules":return A;default:throw new Error("Unsupported linker")}};var He=g.npath.basename(__dirname)==="@yarnpkg"?g.ppath.join(g.npath.toPortablePath(__dirname),"../.."):g.ppath.join(g.npath.toPortablePath(__dirname),".."),Z=async(e,n,t,i,s)=>{let l={},d={children:l},o=await G(e,t,i),c=B(e.configuration.get("nodeLinker"));for(let[r,p]of o.entries()){let h=await c.getPackagePath(e,p);if(h===null)continue;let b=JSON.parse(await c.fs.readFilePromise(g.ppath.join(h,g.Filename.manifest),"utf8")),{license:m,url:L,vendorName:v,vendorUrl:N}=ke(b);l[m]||(l[m]={value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,m),children:{}});let M=a.structUtils.convertPackageToLocator(p),P=a.formatUtils.tuple(a.formatUtils.Type.DEPENDENT,{locator:M,descriptor:r}),y=s?{}:F(F(F({},L?{url:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,V("URL",L,n))}}:{}),v?{vendorName:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,V("VendorName",v,n))}}:{}),N?{vendorUrl:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,V("VendorUrl",N,n))}}:{}),ne={value:P,children:y},oe=a.structUtils.stringifyLocator(M),ie=l[m].children;ie[oe]=ne}return d},G=async(e,n,t)=>{let i=new Map,s;if(n){if(t){for(let c of e.workspaces)c.manifest.devDependencies.clear();let o=await a.Cache.find(e.configuration);await e.resolveEverything({report:new a.ThrowReport,cache:o})}s=e.storedDescriptors.values()}else s=e.workspaces.flatMap(o=>{console.log("workspace"),console.log("locator",o.locator),console.log("anchoredDescriptor",o.anchoredDescriptor),console.log("anchoredLocator",o.anchoredLocator);let c=[o.anchoredDescriptor];for(let[r,p]of o.dependencies.entries())t&&o.manifest.devDependencies.has(r)||(c.push(p),p.name==="babel-loader"&&(console.log("babel-loader found"),console.log("identHash",r),console.log("dependency",p)),(r==="8377c7f4f64ffe06a1668228994fa59ba1a11017a30f97d8d045f4f352c3f84c5d34f0f4c27b081ec27424c0c8d319af10d2acf475b2e74125931254af1753b4"||p.descriptorHash==="8377c7f4f64ffe06a1668228994fa59ba1a11017a30f97d8d045f4f352c3f84c5d34f0f4c27b081ec27424c0c8d319af10d2acf475b2e74125931254af1753b4"||p.range.startsWith("virtual:8377c7f4f64ffe06a1668228994fa59ba1a11017a30f97d8d045f4f352c3f84c5d34f0f4c27b081ec27424c0c8d319af10d2acf475b2e74125931254af1753b4"))&&(console.log("babel loader's yarnState hash found"),console.log("identHash",r),console.log("dependency",p)));return c});console.log("project storedDescriptors",s.filter(o=>o.name==="babel-loader"));let l=a.miscUtils.sortMap(s,[o=>a.structUtils.stringifyIdent(o),o=>a.structUtils.isVirtualDescriptor(o)?"0":"1",o=>o.range]),d=new Set;for(let o of l.values()){let c=e.storedResolutions.get(o.descriptorHash);if(!c)continue;let r=e.storedPackages.get(c);if(!r)continue;r.name==="babel-loader"&&(console.log("identHash",r.identHash),console.log("locatorHash",r.locatorHash),console.log("reference",r.reference));let{descriptorHash:p}=a.structUtils.isVirtualDescriptor(o)?a.structUtils.devirtualizeDescriptor(o):o;d.has(p)||(d.add(p),i.set(o,r))}return i};function ye(e){let n={},t=e.match(/^([^(<]+)/);if(t){let l=t[0].trim();l&&(n.name=l)}let i=e.match(/<([^>]+)>/);i&&(n.email=i[1]);let s=e.match(/\(([^)]+)\)/);return s&&(n.url=s[1]),n}var ke=e=>{let{license:n,licenses:t,repository:i,homepage:s,author:l}=e,d=typeof l=="string"?ye(l):l;return{license:(()=>{if(n)return C(n);if(t){if(!Array.isArray(t))return C(t);if(t.length===1)return C(t[0]);if(t.length>1)return`(${t.map(C).join(" OR ")})`}return Q})(),url:(i==null?void 0:i.url)||s,vendorName:d==null?void 0:d.name,vendorUrl:s||(d==null?void 0:d.url)}},Q="UNKNOWN",C=e=>(typeof e!="string"?e.type:e)||Q,V=(e,n,t)=>t?n:`${e}: ${n}`,X=async(e,n,t)=>{let i=await G(e,n,t),s=B(e.configuration.get("nodeLinker")),l=new Map;for(let o of i.values()){let c=await s.getPackagePath(e,o);if(c===null)continue;let r=JSON.parse(await s.fs.readFilePromise(g.ppath.join(c,g.Filename.manifest),"utf8")),h=(await s.fs.readdirPromise(c,{withFileTypes:!0})).filter(P=>P.isFile()).map(({name:P})=>P),b=h.find(P=>{let y=P.toLowerCase();return y==="license"||y.startsWith("license.")||y==="unlicense"||y.startsWith("unlicense.")});if(!b)continue;let m=await s.fs.readFilePromise(g.ppath.join(c,b),"utf8"),L=h.find(P=>{let y=P.toLowerCase();return y==="notice"||y.startsWith("notice.")}),v;L&&(v=await s.fs.readFilePromise(g.ppath.join(c,L),"utf8"));let N=v?`${m}

NOTICE

${v}`:m,M=l.get(N);M?M.set(r.name,r):l.set(N,new Map([[r.name,r]]))}let d=`THE FOLLOWING SETS FORTH ATTRIBUTION NOTICES FOR THIRD PARTY SOFTWARE THAT MAY BE CONTAINED IN PORTIONS OF THE ${String(e.topLevelWorkspace.manifest.raw.name).toUpperCase().replace(/-/g," ")} PRODUCT.

`;for(let[o,c]of l.entries()){d+=`-----

`;let r=[],p=[];for(let{name:b,repository:m}of c.values())r.push(b),(m==null?void 0:m.url)&&p.push(c.size===1?m.url:`${m.url} (${b})`);let h=[];h.push(`The following software may be included in this product: ${r.join(", ")}.`),p.length>0&&h.push(`A copy of the source code may be downloaded from ${p.join(", ")}.`),h.push("This software contains the following license and notice below:"),d+=`${h.join(" ")}

`,d+=`${o.trim()}

`}return d};var O=class extends w.Command{constructor(){super(...arguments);this.recursive=w.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=w.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});this.json=w.Option.Boolean("--json",!1,{description:"Format output as JSON"});this.excludeMetadata=w.Option.Boolean("--exclude-metadata",!1,{description:"Exclude dependency metadata from output"})}async execute(){let n=await x.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:i}=await x.Project.find(n,this.context.cwd);if(!i)throw new ee.WorkspaceRequiredError(t.cwd,this.context.cwd);await t.restoreInstallState();let s=await Z(t,this.json,this.recursive,this.production,this.excludeMetadata);x.treeUtils.emitTree(s,{configuration:n,stdout:this.context.stdout,json:this.json,separators:1})}};O.paths=[["licenses","list"]],O.usage=w.Command.Usage({description:"display the licenses for all packages in the project",details:`
      This command prints the license information for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the listing will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the listing will exclude development dependencies.
    `,examples:[["List all licenses of direct dependencies","$0 licenses list"],["List all licenses of direct and transitive dependencies","$0 licenses list --recursive"],["List all licenses of production dependencies only","$0 licenses list --production"]]});var te=u(f("@yarnpkg/cli")),E=u(f("@yarnpkg/core")),I=u(f("clipanion"));var j=class extends I.Command{constructor(){super(...arguments);this.recursive=I.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=I.Option.Boolean("--production",!1,{description:"Exclude development dependencies"})}async execute(){let n=await E.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:i}=await E.Project.find(n,this.context.cwd);if(!i)throw new te.WorkspaceRequiredError(t.cwd,this.context.cwd);await t.restoreInstallState();let s=await X(t,this.recursive,this.production);this.context.stdout.write(s)}};j.paths=[["licenses","generate-disclaimer"]],j.usage=I.Command.Usage({description:"display the license disclaimer including all packages in the project",details:`
      This command prints the license disclaimer for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the disclaimer will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the disclaimer will exclude development dependencies.
    `,examples:[["Include licenses of direct dependencies","$0 licenses generate-disclaimer"],["Include licenses of direct and transitive dependencies","$0 licenses generate-disclaimer --recursive"],["Include licenses of production dependencies only","$0 licenses list --production"]]});var we={commands:[O,j]},be=we;return ve;})();
return plugin;
}
};
